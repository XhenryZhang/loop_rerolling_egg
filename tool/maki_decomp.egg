; function that generates an unused integer to create unique names for intermediate variable
(function i64-gen () i64 :merge (+ old 1))
(set (i64-gen) 0)

; immediate wire name
(define wname "w_")

; ripple carry adder name
(define rcadder-name "rc_")

; W is a function that maps "string" to canonical id for WireType
(datatype WireType
    (W String))

; True/False is a WireType with undefined input that evaluates to a unique canonical Id
(declare True WireType)
(declare False WireType)
(declare Empty WireType)

(datatype MakiWexp
    (Wire WireType :cost 1)
    ; SEMANTICS - (Const <value> <bitwidth>)
    (Const i64 i64 :cost 1)
    (HalfAdd MakiWexp MakiWexp :cost 1)
    (NBitAdd MakiWexp MakiWexp MakiWexp :cost 1)
    (And MakiWexp MakiWexp :cost 2)
    (Or MakiWexp MakiWexp :cost 2)
    (Not MakiWexp :cost 2)
    (Xor MakiWexp MakiWexp :cost 2)
    ; SEMANTICS - Concats the two Wexps, where most signficant bit is the most significant bit of the first MakiWexp argument
    (Concat MakiWexp MakiWexp :cost 1)
    ; SEMANTICS - (Select <least sig bit> <most sig bit>) - inclusive
    (Select MakiWexp i64 i64 :cost 1)
    ; SEMANTICS - (AddSum <addend A> <addend B> <carry-in> <ith bit>)
    (AddSum MakiWexp MakiWexp MakiWexp i64 :cost 1)
    ; SEMANTICS - (AddCarry <addend A> <addend B> <carry-in> <ith bit>)
    (AddCarry MakiWexp MakiWexp MakiWexp i64 :cost 1)
)

; Tentative: wires-in-wexp will initially contain all the input wires to the circuit
; After rewriting, Wires should change to include wires (including intermediate wires)
; that will be present as WireVectors in the decompiled Python program. 
(sort Wires (Set WireType))
(function wires-in-wexp (MakiWexp) Wires :merge new :default (set-empty))

; --- rules to identify input wires ---
(rule ((= e (Wire name)))
      ((set (wires-in-wexp e) (set-insert (set-empty) name))))

(rule ((= e (Const value bitwidth)))
      ((set (wires-in-wexp e) (set-empty))))

(rule ((= e (And e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Or e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Xor e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Concat e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Not e1))
       (= (wires-in-wexp e1) w1))
      ((set (wires-in-wexp e) w1)))

(rule ((= e (Select e1 b1 b2))
       (= (wires-in-wexp e1) w1))
      ((set (wires-in-wexp e) w1)))

(rule ((= e (HalfAdd e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

; (rule ((= e (FullAdd e1 e2 e3))
;        (= (wires-in-wexp e1) w1)
;        (= (wires-in-wexp e2) w2)
;        (= (wires-in-wexp e3) w3))
;       ((set (wires-in-wexp e) (set-union w1 (set-union w2 w3)))))

(rule ((= e (NBitAdd e1 e2 e3))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2)
       (= (wires-in-wexp e3) w3))
      ((set (wires-in-wexp e) (set-union w1 (set-union w2 w3)))))

; -------------------------------------
; each wire is associated with a bitwidth (input wires will default to bitwidth of 1)
(function bitwidth-wexp (MakiWexp) i64 :merge new :default 1) 
(function bitwidth-wire (WireType) i64 :merge new :default 1)

(ruleset bitwidth-rules)
; wires upon input have default bitwidth of 1
(rule ((Wire x))
      ((bitwidth-wexp (Wire x))))
(rule ((W x))
      ((bitwidth-wire (W x))))

; Const wexps have bitwidth as part of their syntax
(rule ((= e (Const value bitwidth)))
      ((set (bitwidth-wexp e) bitwidth)))
(rule ((= e (Const value bitwidth))
       (= 0 bitwidth))
      ((panic "ERROR: Bitwidth for a CONST wire cannot be 0")))

; add a rule that preserves bitwidth if operation is not Concat or select
(rule ((= e (And e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
       ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Or e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Xor e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Not e1))
       (= (bitwidth-wexp e1) w1))
      ((set (bitwidth-wexp e) w1)))

(rule ((= e (Select e1 b1 b2))
       (= (bitwidth-wexp e1) w1))
      ((set (bitwidth-wexp e) (+ (- b2 b1) 1))))

(rule ((= e (Select e1 b1 b2))
       (> b1 b2))
      ((panic "ERROR: Bits in SELECT are out of order.")))

(rule ((= e (Concat e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (+ w1 w2))))

(rule ((= e (HalfAdd e1 e2))
       (= (bitwidth-wexp e1) 1)
       (= (bitwidth-wexp e2) 1))
      ((set (bitwidth-wexp e) 2)))

; (rule ((= e (FullAdd e1 e2 e3))
;        (= (bitwidth-wexp e1) 1)
;        (= (bitwidth-wexp e2) 1)
;        (= (bitwidth-wexp e3) 1))
;       ((set (bitwidth-wexp e) 2)))

(rule ((= e (NBitAdd e1 e2 e3))
       (= (bitwidth-wexp e1) n)
       (= (bitwidth-wexp e2) n)
       (= (bitwidth-wexp e3) 1))
      ((set (bitwidth-wexp e) (+ n 1))))

; check carry-in bits are 1 bit
; the Empty wire is also one bit, but it represents 0 wire
(rule ((= e (NBitAdd e1 e2 e3))
       (!= (bitwidth-wexp e3) 1))
      ((panic "ERROR: carry-in wires to adder should be 1 bit in width")))

; (rule ((= e (FullAdd e1 e2 e3))
;        (!= (bitwidth-wexp e3) 1))
;       ((panic "ERROR: carry-in wires to adder should be 1 bit in width")))
;--------------------------------------------------------------------

; --- POTENTIAL: rules to create intermediate wires ---
; idea: if we count the number of repeated netlist elements in the original, set a counter
; if the counter reaches a user-defined value, create a new WireType and associate it
; with that wire expression via the evals-to function.
; ------------------------------------------

; associate intermediate (non-input) wires with the MakiWexp they represent
; TODO: in the final tool, do (print evals-to) and parse its output
; TODO: in the final tool, do (print bitwidth-wire) and parse its output
; TODO: in the final tool, set our input and output wires
(function evals-to (WireType) MakiWexp :cost 10000)
(sort Wires (Set MakiWexp))

; update bitwidths for intermediate wire variables
(rule ((= (evals-to name) wexp)
       (= (bitwidth-wexp wexp) w))
      ((set (bitwidth-wire name) w)))

; --- rewrite rules ---
(ruleset rewrite-rules)
; comm-and
(rewrite (And a b) (And b a))
; assoc-and
(rewrite (And (And a b) c) (And a (And b c)))
; comm-or
(rewrite (Or a b) (Or b a))
; assoc-or
(rewrite (Or (Or a b) c) (Or a (Or b c)))
; comm-xor
(rewrite (Xor a b) (Xor b a))
; assoc-xor
(rewrite (Xor (Xor a b) c) (Xor a (Xor b c)))
; double-neg
(rewrite (Not (Not a)) a)
; or-true
(rewrite (Or a (Not a)) (Wire True))
; and-false
(rewrite (And a (Not a)) (Wire False))
; and-identity
(rewrite (And a (Wire True)) a)
; or-identity
(rewrite (Or a (Wire False)) a)
; or-kill
(rewrite (Or a (Wire True)) (Wire True))
; and-kill
(rewrite (And a (Wire False)) (Wire False))
; and-idem
(rewrite (And a a) a)
; or-idem
(rewrite (Or a a) a)
; absorb1
(rewrite (Or a (And a b)) a)
; absorb2
(rewrite (And a (Or a b)) a)
; absorb3
(rewrite (And a (Or (Not a) b)) (And a b))
; absorb4
(rewrite (Or a (And (Not a) b)) (Or a b))
; xor-neg-id
(rewrite (Xor a (Wire True)) (Not a))
; xor-identity
(rewrite (Xor a (Wire False)) a)
; xor-idem
(rewrite (Xor a a) (Wire False))
; TRUE/FALSE
(rewrite (Wire False) (Const 0 1))
(rewrite (Wire True) (Const 1 1))

; ----- bidirectional rewrite rules -----
; xor-conv
(rewrite (Xor a b) (And (Or a b) (Not (And a b))))
; xor-conv2
(rewrite (Xor a b) (Or (And (Not a) b) (And a (Not b))))
; xor-and-comm
(rewrite (Or (And a b) (And c (Xor a b))) (Or (And a c) (And b (Xor a c))))
; demorgan
(birewrite (Or (Not a) (Not b)) (Not (And a b)))
; demorgan2
(birewrite (And (Not a) (Not b)) (Not (Or a b)))
; dist-and-or
(rewrite (Or (And a b) (And a c)) (And a (Or b c)))
; dist-or-and
(rewrite (And (Or a b) (Or a c)) (Or a (And b c)))
; ----------------------------------------
; AddSum, AddCarry
(function ripple-carry (String) MakiWexp :cost 10000)

; TODO - make a set data type that stores MakiWexp types
; question: do we have to name every wire
; maki expression with 2 half add on the same wire, does it find 1 or does it find 2 
; does egglog treat equivalent netlist elements as the same? (see if my method duplicates)

; half-add new
(rewrite (And a b) (AddCarry a b (Wire Empty) 0))
(rewrite (Xor a b) (AddSum a b (Wire Empty) 0))

(rule ((= c (And a b)) (= sum (Xor a b)))
      ((let name (+ rcadder-name "ha_" (to-str (i64-gen))))
       (set (i64-gen) -1)
       (set (ripple-carry name) (HalfAdd a b))))

; full-add
(rewrite (Xor (Xor a b) cin) (AddSum a b cin 0))
(rewrite (Or (Or (And a b) (And a cin)) (And b cin)) (AddCarry a b cin 0))
(rewrite (Or (And a b) (And cin (Xor b a))) (AddCarry a b cin 0))

; comm-nbit-add
(rewrite (NBitAdd a b c) (NBitAdd b a c))

; n-bit-add to n+1-bit-add
(rewrite (Xor (Xor a2 b2) (AddCarry a b cin n)) (AddSum (Concat a2 a) (Concat b2 b) cin (+ n 1)))
(rewrite (Or (Or (And a2 b2) (And a2 (AddCarry a b cin n))) (And b1 (AddCarry a b cin n))) (AddCarry (Concat a2 a) (Concat b2 b) cin (+ n 1)))
(rewrite (Or (And a2 b2) (And (AddCarry a b cin n) (Xor b2 a2))) (AddCarry (Concat a2 a) (Concat b2 b) cin (+ n 1)))

; TODO: make sure it is idempotent, or same name
; 1. everything gets a unique name
; 2. deduplicate identical structure within AST

; TODO: make intermediate wires
; TODO: make Jinja2 template
(rule ((= c (AddCarry a b cin n)) (= sum (AddSum a b cin n)))
      ((let name (+ rcadder-name (to-str (+ n 1)) "bit_" (to-str (i64-gen))))
       (set (i64-gen) -1)
       (set (ripple-carry name) (NBitAdd a b cin))))
; ----------------------------------------------
; half-add
; (rewrite (Concat (And a b) (Xor a b)) (HalfAdd a b))

; full-add
; (rewrite (Concat (Or (Or (And a b) (And a cin)) (And b cin)) (Xor (Xor a b) cin)) (FullAdd a b cin))
; (rewrite (Concat (Or (And a b) (And cin (Xor b a))) (Xor (Xor a b) cin)) (FullAdd a b cin))

; (base case) full-add to 2-bit-add
; (rewrite (Concat (FullAdd a1 b1 (Select (FullAdd a0 b0 cin) 1 1)) (Select (FullAdd a0 b0 cin) 0 0))
;         (NBitAdd a0 b0 cin))
; (rule ((= v (Concat (FullAdd a1 b1 (Select (FullAdd a0 b0 cin) 1 1)) (Select (FullAdd a0 b0 cin) 0 0))))
;       ((let op1 (Concat a1 a0))
;        (let op2 (Concat b1 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1) ; increment number tracker
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) cin))))

; ; (inductive case) n-bit-add to n+1-bit-add
; (rule ((= v (Concat (FullAdd a2 b2 (Select (NBitAdd a0 b0 cin) x x)) (Select (NBitAdd a0 b0 cin) 0 (- x 1))))) 
;       ((let op1 (Concat a2 a0))
;        (let op2 (Concat b2 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) cin))))

; ; (base case) full-add to 2-bit-add without carry in
; ; Wire "Empty" indicates no carry bit is input to the 2-bit-add
; (rewrite (Concat (FullAdd a1 b1 (Select (HalfAdd a0 b0) 1 1)) (Select (HalfAdd a0 b0) 0 0))
         ; (NBitAdd a0 b0 (Wire Empty)))
; (rule ((= v (Concat (FullAdd a1 b1 (Select (HalfAdd a0 b0) 1 1)) (Select (HalfAdd a0 b0) 0 0))))
;       ((let op1 (Concat a1 a0))
;        (let op2 (Concat b1 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1) ; increment number tracker
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) (Wire Empty)))))

; (inductive case) n-bit-add to n+1-bit-add
; (rule ((= v (Concat (FullAdd a2 b2 (Select (NBitAdd a0 b0 (Wire Empty)) x x)) (Select (NBitAdd a0 b0 (Wire Empty)) 0 (- x 1))))) 
;       ((let op1 (Concat a2 a0))
;        (let op2 (Concat b2 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) (Wire Empty)))))
; ----------------------------------------


