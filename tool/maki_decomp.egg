; function that generates an unused integer to create unique names for intermediate variable
(function i64-gen () i64 :merge (+ old 1))
(set (i64-gen) 0)

; immediate wire name
(define wname "w_")

; ripple carry adder name w/ carry bit
(define rcadder-name-no-carry "rcc_")

; ripple carry adder name w/o carry bit
(define rcadder-name "rc_")

; W is a function that maps "string" (wire name) to canonical id for WireType
(datatype WireType
      (W String))

; True/False is a WireType with undefined input that evaluates to a unique canonical Id
(declare True WireType)
(declare False WireType)
(declare Empty WireType)

(datatype MakiWexp
      ; ------ netlist circuit components ------
      (Wire WireType :cost 1)
      ; SEMANTICS - (Const <value> <bitwidtrh>)
      (Const i64 i64 :cost 1)
      (And MakiWexp MakiWexp :cost 3)
      (Or MakiWexp MakiWexp :cost 3)
      (Not MakiWexp :cost 3)
      (Xor MakiWexp MakiWexp :cost 3)
      ; SEMANTICS - Concats the two Wexps, where most signficant bit is
      ; the most significant bit of the first MakiWexp argument
      (Concat MakiWexp MakiWexp :cost 1)
      ; SEMANTICS - (Select <least sig bit> <most sig bit>) - inclusive
      (Select MakiWexp i64 i64 :cost 1)
      ; SEMANTICS - (AddSum <addend A> <addend B> <carry-in> <ith bit>)
      
      ; ------ high-level circuit components ------
      (AddSum MakiWexp MakiWexp MakiWexp i64 :cost 1)
      ; SEMANTICS - (AddCarry <addend A> <addend B> <carry-in> <ith bit>)
      (AddCarry MakiWexp MakiWexp MakiWexp i64 :cost 1)

      ; ------ high-level global information ------
      (HalfAdd MakiWexp MakiWexp)
      (NBitAdd MakiWexp MakiWexp MakiWexp)
      (NBitAddNoCarry MakiWexp MakiWexp MakiWexp)
)

; wires-in-wexp will initially contain all the input wires to the circuit
; After rewriting, Wires should change to include wires (including intermediate wires)
; that will be present as WireVectors in the decompiled Python program. 
(sort Wires (Set WireType))
(function wires-in-wexp (MakiWexp) Wires :merge new :default (set-empty))

; --- rules to identify input wires ---
(rule ((= e (Wire name)))
      ((set (wires-in-wexp e) (set-insert (set-empty) name))))

(rule ((= e (Const value bitwidth)))
      ((set (wires-in-wexp e) (set-empty))))

(rule ((= e (And e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Or e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Xor e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Concat e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (Not e1))
       (= (wires-in-wexp e1) w1))
      ((set (wires-in-wexp e) w1)))

(rule ((= e (Select e1 b1 b2))
       (= (wires-in-wexp e1) w1))
      ((set (wires-in-wexp e) w1)))

(rule ((= e (HalfAdd e1 e2))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2))
      ((set (wires-in-wexp e) (set-union w1 w2))))

(rule ((= e (NBitAdd e1 e2 e3))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2)
       (= (wires-in-wexp e3) w3))
      ((set (wires-in-wexp e) (set-union w1 (set-union w2 w3)))))

(rule ((= e (NBitAddNoCarry e1 e2 e3))
       (= (wires-in-wexp e1) w1)
       (= (wires-in-wexp e2) w2)
       (= (wires-in-wexp e3) w3))
      ((set (wires-in-wexp e) (set-union w1 (set-union w2 w3)))))

; -------------------------------------
; each wire is associated with a bitwidth (input wires will default to bitwidth of 1)
(function bitwidth-wexp (MakiWexp) i64 :merge new :default 1) 
(function bitwidth-wire (WireType) i64 :merge new :default 1)

(ruleset bitwidth-rules)
; wires upon input have default bitwidth of 1
(rule ((Wire x))
      ((bitwidth-wexp (Wire x))))
(rule ((W x))
      ((bitwidth-wire (W x))))

; Const wexps have bitwidth as part of their syntax
(rule ((= e (Const value bitwidth)))
      ((set (bitwidth-wexp e) bitwidth)))
(rule ((= e (Const value bitwidth))
       (= 0 bitwidth))
      ((panic "ERROR: Bitwidth for a CONST wire cannot be 0")))

; add a rule that preserves bitwidth if operation is not Concat or select
(rule ((= e (And e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
       ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Or e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Xor e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (max w1 w2))))

(rule ((= e (Not e1))
       (= (bitwidth-wexp e1) w1))
      ((set (bitwidth-wexp e) w1)))

(rule ((= e (Select e1 b1 b2))
       (= (bitwidth-wexp e1) w1))
      ((set (bitwidth-wexp e) (+ (- b2 b1) 1))))

(rule ((= e (Select e1 b1 b2))
       (> b1 b2))
      ((panic "ERROR: Bits in SELECT are out of order.")))

(rule ((= e (Concat e1 e2))
       (= (bitwidth-wexp e1) w1)
       (= (bitwidth-wexp e2) w2))
      ((set (bitwidth-wexp e) (+ w1 w2))))

(rule ((= e (HalfAdd e1 e2))
       (= (bitwidth-wexp e1) 1)
       (= (bitwidth-wexp e2) 1))
      ((set (bitwidth-wexp e) 2)))

(rule ((= e (NBitAdd e1 e2 e3))
       (= (bitwidth-wexp e1) n)
       (= (bitwidth-wexp e2) n)
       (= (bitwidth-wexp e3) 1))
      ((set (bitwidth-wexp e) (+ n 1))))

(rule ((= e (NBitAddNoCarry e1 e2 e3))
       (= (bitwidth-wexp e1) n)
       (= (bitwidth-wexp e2) n)
       (= (bitwidth-wexp e3) 1))
      ((set (bitwidth-wexp e) n)))

; check carry-in bits are 1 bit
; the Empty wire is also one bit, but it represents 0 wire
(rule ((= e (NBitAdd e1 e2 e3))
       (!= (bitwidth-wexp e3) 1))
      ((panic "ERROR: carry-in wires to adder should be 1 bit in width")))

(rule ((= e (NBitAddNoCarry e1 e2 e3))
       (!= (bitwidth-wexp e3) 1))
      ((panic "ERROR: carry-in wires to adder should be 1 bit in width")))
;--------------------------------------------------------------------

; --- TODO: rules to create intermediate wires ------
; idea: if we count the number of repeated netlist elements in the original, set a counter
; if the counter reaches a user-defined value, create a new WireType and associate it
; with that wire expression via the evals-to function
; ---------------------------------------------------

; --- TODO: rules to create intermediate rewrites ---
; in the final tool, do (print evals-to) and parse its output
; in the final tool, do (print bitwidth-wire) and parse its output
; in the final tool, do (print ripple-carry) and parse its output
; ---------------------------------------------------

; associate intermediate (non-input) wires with the MakiWexp they represent
(function evals-to (WireType) MakiWexp :cost 10000)

; update bitwidths for intermediate wire variables
(rule ((= (evals-to name) wexp)
       (= (bitwidth-wexp wexp) w))
      ((set (bitwidth-wire name) w)))

; --- saturating rewrite rules ---
(ruleset sat-rewrite-rules)
; comm-and
(rewrite (And a b) (And b a))
; assoc-and
(rewrite (And (And a b) c) (And a (And b c)))
; comm-or
(rewrite (Or a b) (Or b a))
; assoc-or
(rewrite (Or (Or a b) c) (Or a (Or b c)))
; comm-xor
(rewrite (Xor a b) (Xor b a))
; assoc-xor
(rewrite (Xor (Xor a b) c) (Xor a (Xor b c)))
; double-neg
(rewrite (Not (Not a)) a)
; or-true
(rewrite (Or a (Not a)) (Wire True))
; and-false
(rewrite (And a (Not a)) (Wire False))
; and-identity
(rewrite (And a (Wire True)) a)
; or-identity
(rewrite (Or a (Wire False)) a)
; or-kill
(rewrite (Or a (Wire True)) (Wire True))
; and-kill
(rewrite (And a (Wire False)) (Wire False))
; and-idem
(rewrite (And a a) a)
; or-idem
(rewrite (Or a a) a)
; absorb1
(rewrite (Or a (And a b)) a)
; absorb2
(rewrite (And a (Or a b)) a)
; absorb3
(rewrite (And a (Or (Not a) b)) (And a b))
; absorb4
(rewrite (Or a (And (Not a) b)) (Or a b))
; xor-neg-id
(rewrite (Xor a (Wire True)) (Not a))
; xor-identity
(rewrite (Xor a (Wire False)) a)
; xor-idem
(rewrite (Xor a a) (Wire False))
; TRUE/FALSE
(rewrite (Wire False) (Const 0 1))
(rewrite (Wire True) (Const 1 1))
; xor-conv
(rewrite (Xor a b) (And (Or a b) (Not (And a b))))
; xor-conv2
(rewrite (Xor a b) (Or (And (Not a) b) (And a (Not b))))
; xor-and-comm
(rewrite (Or (And a b) (And c (Xor a b))) (Or (And a c) (And b (Xor a c))))
; demorgan
(birewrite (Or (Not a) (Not b)) (Not (And a b)))
; demorgan2
(birewrite (And (Not a) (Not b)) (Not (Or a b)))
; dist-and-or
(rewrite (Or (And a b) (And a c)) (And a (Or b c)))
; dist-or-and
(rewrite (And (Or a b) (Or a c)) (Or a (And b c)))
; ----------------------------------------

; This function maps generated names to ripple-carry adders present in the circuit
(function ripple-carry (String) MakiWexp :cost 100000)

; identify 0th sum bit of a ripple carry adder
(rewrite (Xor (Xor a b) cin) (AddSum a b cin 0))
(rewrite (Xor a b) (AddSum a b (Wire Empty) 0))

; identify 0th carry bit of a ripple carry adder
(rewrite (And a b) (AddCarry a b (Wire Empty) 0))
(rewrite (Or (Or (And a b) (And a cin)) (And b cin)) (AddCarry a b cin 0))
(rewrite (Or (And a b) (And cin (Xor a b))) (AddCarry a b cin 0))

; identify n+1th sum bit of a ripple carry adder
(rewrite (Xor (Xor a2 b2) (AddCarry a b cin n)) 
         (AddSum (Concat a2 a) (Concat b2 b) cin (+ n 1)))

; identify n+1th carry bit of a ripple carry adder
(rewrite (Or (Or (And a2 b2) (And a2 (AddCarry a b cin n))) (And b1 (AddCarry a b cin n)))
         (AddCarry (Concat a2 a) (Concat b2 b) cin (+ n 1)))
(rewrite (Or (And a2 b2) (And (AddCarry a b cin n) (Xor b2 a2))) 
         (AddCarry (Concat a2 a) (Concat b2 b) cin (+ n 1)))

; comm sum and carry bits
(rewrite (AddSum a b cin n) (AddSum b a cin n))
(rewrite (AddCarry a b cin n) (AddCarry b a cin n))

; --- [FAILED ATTEMPT]: deduplicate adders, since the same additive rules will be triggered each cycle ---
; Motivation - make a set data type that stores MakiWexp types
; question: do we have to name every wire uniquely, to prevent duplication, or is another 
; maki expression with 2 half add on the same wire, does it find 1 or does it find 2 
; does egglog treat equivalent netlist elements as the same? NO

; OPTIMIZE: this hacky approach reduces the number of duplicate statements, but not completely if there are
; multiple (And) structures appear in the same tree structure

; (sort AdderSet (Set MakiWexp)) 
; (function dedup-adder (String) AdderSet :merge (set-union old new))
; (set (dedup-adder "default") (set-of (Wire (W "ignorethis")))) ; hacky method since we can't make an empty set -- implicitly types to WireType since empty set binds to the first custom sort encountered   

; (rule ((= (And a b) c) (= (Xor a b) sum) (set-not-contains (dedup-adder "default") sum))
;       ((let name (+ rcadder-name "ha_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (ripple-carry name) (HalfAdd a b))
;        (set (dedup-adder "default") (set-of sum))))

; (rule ((= c (AddCarry a b cin n)) (= sum (AddSum a b cin n)) (set-not-contains (dedup-adder "default") c))
;       ((let name (+ rcadder-name (to-str (+ n 1)) "bit_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (ripple-carry name) (NBitAdd a b cin))
;        (set (dedup-adder "default") (set-of c))))

; (rule ((= sum (AddSum a b cin n)) (set-not-contains (dedup-adder "default") sum))
;       ((let name (+ rcadder-name-no-carry (to-str (+ n 1)) "bit_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (ripple-carry name) (NBitAddNoCarry a b cin))
;        (set (dedup-adder "default") (set-of sum))))
; ---------------------------------------------------------------------------------------------------------

; ------- WORKING -------
; halfadd (with carry-out bit) -- w/o carry bit is just XOR gate
(rule ((= (And a b) c) (= (Xor a b) sum))
      ((let name (+ rcadder-name "ha_" (to-str (i64-gen))))
       (set (i64-gen) -1)
       (set (ripple-carry name) (HalfAdd a b))))

; nbitadd with carry-in bit with carry-out bit
(rule ((= c (AddCarry a b cin n)) (= sum (AddSum a b cin n)))
      ((set (i64-gen) -1)
       (let name (+ rcadder-name (to-str (+ n 1)) "bit_" (to-str (i64-gen))))
       (set (ripple-carry name) (NBitAdd a b cin))))

; nbitadd with carry-in bit without carry-out bit
(rule ((= sum (AddSum a b cin n)))
      ((set (i64-gen) -1)
       (let name (+ rcadder-name-no-carry (to-str (+ n 1)) "bit_" (to-str (i64-gen))))
       (set (ripple-carry name) (NBitAddNoCarry a b cin))))

; nbitadd without carry-in bit with carry-out bit
;(rule ((=)))

; nbitadd without carry-in bit without carry-out bit
;()
;-------------------------

; n-bit-add to n+1-bit-add
; (rule ((= (Xor (Xor a2 b2) (AddCarry a b cin n)) sum))
;       ((let op1 (Concat a2 a))
;        (let op2 (Concat b2 b))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1) ; increment number tracker
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union sum (AddSum (Wire (W name1)) (Wire (W name2)) cin (+ n 1)))))

; (rule ((= (Or (Or (And a2 b2) (And a2 (AddCarry a b cin n))) (And b1 (AddCarry a b cin n))) carry))
;       ((let op1 (Concat a2 a))
;        (let op2 (Concat b2 b))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union carry (AddCarry (Wire (W name1)) (Wire (W name2)) cin (+ n 1)))))

; (rule ((= (Or (And a2 b2) (And (AddCarry a b cin n) (Xor b2 a2))) ac))
;       ((let op1 (Concat a2 a))
;        (let op2 (Concat b2 b))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union ac (AddCarry (Wire (W name1)) (Wire (W name2)) cin (+ n 1)))))
; ----------------------------------------------

; DEPRECATED: rewrite rules for a previous version of MakiWexp that relies on additional CONCAT and SELECT statements in the netlist to trigger.
; The chicken-and-egg problem is mentioned in the project report

; half-add
; (rewrite (Concat (And a b) (Xor a b)) (HalfAdd a b))

; full-add
; (rewrite (Concat (Or (Or (And a b) (And a cin)) (And b cin)) (Xor (Xor a b) cin)) (FullAdd a b cin))
; (rewrite (Concat (Or (And a b) (And cin (Xor b a))) (Xor (Xor a b) cin)) (FullAdd a b cin))

; (base case) full-add to 2-bit-add
; (rewrite (Concat (FullAdd a1 b1 (Select (FullAdd a0 b0 cin) 1 1)) (Select (FullAdd a0 b0 cin) 0 0))
;         (NBitAdd a0 b0 cin))
; (rule ((= v (Concat (FullAdd a1 b1 (Select (FullAdd a0 b0 cin) 1 1)) (Select (FullAdd a0 b0 cin) 0 0))))
;       ((let op1 (Concat a1 a0))
;        (let op2 (Concat b1 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1) ; increment number tracker
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) cin))))

; ; (inductive case) n-bit-add to n+1-bit-add
; (rule ((= v (Concat (FullAdd a2 b2 (Select (NBitAdd a0 b0 cin) x x)) (Select (NBitAdd a0 b0 cin) 0 (- x 1))))) 
;       ((let op1 (Concat a2 a0))
;        (let op2 (Concat b2 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) cin))))

; ; (base case) full-add to 2-bit-add without carry in
; ; Wire "Empty" indicates no carry bit is input to the 2-bit-add
; (rewrite (Concat (FullAdd a1 b1 (Select (HalfAdd a0 b0) 1 1)) (Select (HalfAdd a0 b0) 0 0))
         ; (NBitAdd a0 b0 (Wire Empty)))
; (rule ((= v (Concat (FullAdd a1 b1 (Select (HalfAdd a0 b0) 1 1)) (Select (HalfAdd a0 b0) 0 0))))
;       ((let op1 (Concat a1 a0))
;        (let op2 (Concat b1 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1) ; increment number tracker
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) (Wire Empty)))))

; (inductive case) n-bit-add to n+1-bit-add
; (rule ((= v (Concat (FullAdd a2 b2 (Select (NBitAdd a0 b0 (Wire Empty)) x x)) (Select (NBitAdd a0 b0 (Wire Empty)) 0 (- x 1))))) 
;       ((let op1 (Concat a2 a0))
;        (let op2 (Concat b2 b0))
;        (let name1 (+ wname "addend1_" (to-str (i64-gen))))
;        (let name2 (+ wname "addend2_" (to-str (i64-gen))))
;        (set (i64-gen) -1)
;        (set (evals-to (W name1)) op1)
;        (set (evals-to (W name2)) op2)
;        (union v (NBitAdd (Wire (W name1)) (Wire (W name2)) (Wire Empty)))))
; ----------------------------------------


